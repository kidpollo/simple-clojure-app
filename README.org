* Simple clojure application

  This is very simple Clojure application developed with literate programming
  principles. This project demonstrates a simple parser of text files alongside
  a simple simple REST service to interact with the data.

** Project setup

  This project should require minimal structure and deps. We need a ~src~ and
  ~test~ folder for our code. A ~resources~ folder for static assets like sample
  input files and a ~dev~ folder for any supporting dev enviroment work.

#+BEGIN_SRC bash :results silent
mkdir -p src/simple_app
mkdir -p test/simple_app
mkdir -p dev
mkdir -p resources
#+END_SRC

  For project deps we are going to use [[http://pedestal.io][Pedestal]] for the REST api portion of
  things. This is my first go at using Pedestal so it should be fun. For testing
  we are going to use the cognitect test runner.

#+begin_src clojure :tangle deps.edn :results silent :eval no
{:deps
 {org.clojure/clojure {:mvn/version "1.10.1"}
  io.pedestal/pedestal.service {:mvn/version "0.5.7"}
  io.pedestal/pedestal.route {:mvn/version "0.5.7"}
  io.pedestal/pedestal.jetty {:mvn/version "0.5.7"}
  org.slf4j/slf4j-simple {:mvn/version "1.7.28"}}

 :aliases
 {:test
  {:extra-paths ["test"]
   :extra-deps {com.cognitect/test-runner
                {:git/url "https://github.com/cognitect-labs/test-runner.git"
                 :sha "209b64504cb3bd3b99ecfec7937b358a879f55c1"}}
   :main-opts ["-m" "cognitect.test-runner"]}}}
#+end_src

  And we need a ~.gitignore~ file.

#+begin_src bash :tangle .gitignore :results silent :eval no
.cpcache
.nrepl-port
#+end_src

** The data model

  I like to start with data modeling and design desitions as early as possible.
  For this app we are goint ro handle records of a simple shape but its still
  worth having clojure specs to validate data going through any system.

#+begin_src clojure :tangle src/simple_app/spec.clj :results silent
(ns simple-app.specs
  (:require [clojure.spec.alpha :as s]))

(s/def :simple-app/last-name string?)
(s/def :simple-app/first-name string?)
(s/def :simple-app/gender string?)
(s/def :simple-app/favorite-color string?)
(s/def :simple-app/date-of-birth inst?)

(s/def :simple-app/record (s/keys :req-un [:simple-app/first-name
                                           :simple-app/last-name
                                           :simple-app/gender
                                           :simple-app/favorite-color
                                           :simple-app/date-of-birth]))
#+end_src

  Lets play a bit with this specs.

#+begin_src clojure :ns simple-app.specs :tangle dev/scratch.clj :results output :exports both
(s/explain :simple-app/last-name 1)
(s/explain :simple-app/last-name "foo")
(s/explain :simple-app/date-of-birth "1/1/1")
(s/explain :simple-app/date-of-birth (java.util.Date.))
(s/explain :simple-app/record {})
(s/explain :simple-app/record {:first-name "foo"
                               :last-name "bar"
                               :gender "neutral"
                               :favorite-color "chartreuse"
                               :date-of-birth (java.util.Date.)})
#+end_src

#+RESULTS:
#+begin_example
1 - failed: string? spec: :simple-app/last-name
Success!
"1/1/1" - failed: inst? spec: :simple-app/date-of-birth
Success!
{} - failed: (contains? % :first-name) spec: :simple-app/record
{} - failed: (contains? % :last-name) spec: :simple-app/record
{} - failed: (contains? % :gender) spec: :simple-app/record
{} - failed: (contains? % :favorite-color) spec: :simple-app/record
{} - failed: (contains? % :date-of-birth) spec: :simple-app/record
Success!
#+end_example
