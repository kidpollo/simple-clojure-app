* Simple clojure application

  This is very simple Clojure application developed with literate programming
  principles. This project demonstrates a simple parser of text files alongside
  a simple simple REST service to interact with the data.

** Project setup

  This project should require minimal structure and deps. We need a ~src~ and
  ~test~ folder for our code. A ~resources~ folder for static assets like sample
  input files and a ~dev~ folder for any supporting dev enviroment work.

#+BEGIN_SRC bash :results silent
mkdir -p src/simple_app
mkdir -p test/simple_app
mkdir -p dev
mkdir -p resources
#+END_SRC

  For project deps we are going to use [[http://pedestal.io][Pedestal]] for the REST api portion of
  things. This is my first go at using Pedestal so it should be fun. For testing
  we are going to use the cognitect test runner.

#+begin_src clojure :tangle deps.edn :results silent :eval no
{:deps
 {org.clojure/clojure {:mvn/version "1.10.1"}
  org.clojure/data.json {:mvn/version "1.0.0"}
  io.pedestal/pedestal.service {:mvn/version "0.5.7"}
  io.pedestal/pedestal.route {:mvn/version "0.5.7"}
  io.pedestal/pedestal.jetty {:mvn/version "0.5.7"}
  org.slf4j/slf4j-simple {:mvn/version "1.7.28"}}

 :aliases
 {:test
  {:extra-paths ["test"]
   :extra-deps {com.cognitect/test-runner
                {:git/url "https://github.com/cognitect-labs/test-runner.git"
                 :sha "209b64504cb3bd3b99ecfec7937b358a879f55c1"}}
   :main-opts ["-m" "cognitect.test-runner"]}}}
#+end_src

  And we need a ~.gitignore~ file.

#+begin_src bash :tangle .gitignore :results silent :eval no
.cpcache
.nrepl-port
#+end_src

** The data model

  I like to start with data modeling and design decisions as early as possible.
  For this app we are goint to handle records of a simple shape but its still
  worth having clojure specs to validate data going through any system.

#+begin_src clojure :tangle src/simple_app/spec.clj :results silent
(ns simple-app.specs
  (:require [clojure.spec.alpha :as s]))

(s/def :simple-app/last-name string?)
(s/def :simple-app/first-name string?)
(s/def :simple-app/gender string?)
(s/def :simple-app/favorite-color string?)
(s/def :simple-app/date-of-birth inst?)

(s/def :simple-app/record (s/keys :req-un [:simple-app/first-name
                                           :simple-app/last-name
                                           :simple-app/gender
                                           :simple-app/favorite-color
                                           :simple-app/date-of-birth]))

(s/def :simple-app/records (s/coll-of :simple-app/record))
#+end_src

  Lets play a bit with this specs.

#+begin_src clojure :ns simple-app.specs :tangle dev/scratch.clj :results output :exports both
(s/explain :simple-app/last-name 1)
(s/explain :simple-app/last-name "foo")
(s/explain :simple-app/date-of-birth "1/1/1")
(s/explain :simple-app/date-of-birth (java.util.Date.))
(s/explain :simple-app/record {})
(s/explain :simple-app/record {:first-name "foo"
                               :last-name "bar"
                               :gender "neutral"
                               :favorite-color "chartreuse"
                               :date-of-birth (java.util.Date.)})
#+end_src

#+RESULTS:
#+begin_example
1 - failed: string? spec: :simple-app/last-name
Success!
"1/1/1" - failed: inst? spec: :simple-app/date-of-birth
Success!
{} - failed: (contains? % :first-name) spec: :simple-app/record
{} - failed: (contains? % :last-name) spec: :simple-app/record
{} - failed: (contains? % :gender) spec: :simple-app/record
{} - failed: (contains? % :favorite-color) spec: :simple-app/record
{} - failed: (contains? % :date-of-birth) spec: :simple-app/record
Success!
#+end_example

** Data parsing

  This simple-app can injest data via input file from the command line. The only
  relevant business logic worth testing here is a function that will take 1 at a
  time from the input file and parse it into a map that we can validate with our
  specs.

#+begin_src clojure :tangle src/simple_app/record.clj :results silent
(ns simple-app.record
  (:require [clojure.spec.alpha :as s]))

(defn parse [line] 
  {})
#+end_src

  We start with a simple parse file that does nothing so we can write the tests
  first.

#+begin_src clojure :tangle test/simple_app/record_test.clj :results silent
(ns simple-app.record-test
  (:require [simple-app.record :as record]
            [clojure.test :refer [deftest testing is]]))

(deftest parse-test
  (let [expected {:first-name "foo"
                  :last-name "bar"
                  :gender "neutral"
                  :favorite-color "chartreuse"
                  :date-of-birth (java.util.Date. "1/1/2020")}
        pipe-format "foo | bar | neutral | chartreuse | 1/1/2020"
        comma-format "foo, bar, neutral, chartreuse, 1/1/2020"
        space-format "foo bar neutral chartreuse 1/1/2020"]

    (testing "Pipe format"
      (is (= (record/parse pipe-format) expected)))
    (testing "Comma format"
      (is (= (record/parse comma-format) expected)))
    (testing "Space format"
      (is (= (record/parse space-format) expected)))))
#+end_src

  Lets run the tests.

#+begin_src clojure :ns clojure.test :tangle dev/scratch.clj :results output :exports both
(run-tests 'simple-app.record-test)
#+end_src

#+RESULTS:
#+begin_example

Testing simple-app.record-test

FAIL in (parse-test) (NO_SOURCE_FILE:16)
Pipe format
expected: (= (record/parse pipe-format) expected)
  actual: (not (= {} {:first-name "foo", :last-name "bar", :gender "neutral", :favorite-color "chartreuse", :date-of-birth #inst "2020-01-01T08:00:00.000-00:00"}))

FAIL in (parse-test) (NO_SOURCE_FILE:18)
Comma format
expected: (= (record/parse comma-format) expected)
  actual: (not (= {} {:first-name "foo", :last-name "bar", :gender "neutral", :favorite-color "chartreuse", :date-of-birth #inst "2020-01-01T08:00:00.000-00:00"}))

FAIL in (parse-test) (NO_SOURCE_FILE:20)
Space format
expected: (= (record/parse space-format) expected)
  actual: (not (= {} {:first-name "foo", :last-name "bar", :gender "neutral", :favorite-color "chartreuse", :date-of-birth #inst "2020-01-01T08:00:00.000-00:00"}))

Ran 1 tests containing 3 assertions.
3 failures, 0 errors.
#+end_example

  Ok now we actually build our parse function.

#+begin_src clojure :ns simple-app.record :tangle src/simple_app/record.clj :results silent
(require '[clojure.string :as str])

(defn parse
  "Parses input line into a record entry map.
  Handles 3 different input formats.
    - Comma separated
    - Pipe separated
    - Space separated"
  [line]
  (-> (zipmap [:first-name :last-name :gender :favorite-color :date-of-birth]
              (str/split line #",\s+|\s+\|\s+|\s+"))
      (update :date-of-birth #(java.util.Date. %))))
#+end_src

  Tests pass now :D

#+begin_src clojure :ns clojure.test :tangle dev/scratch.clj :results output :exports both
(run-tests 'simple-app.record-test)
#+end_src

#+RESULTS:
: 
: Testing simple-app.record-test
: 
: Ran 1 tests containing 3 assertions.
: 0 failures, 0 errors.

  Now lets write a simple program that puts it all together.

#+begin_src clojure :tangle src/simple_app/core.clj :results silent
(ns simple-app.core
  (:require [simple-app.record :as record]
            [clojure.java.io :as io]))

(defn process-file-by-lines
  "Process file reading it line-by-line
  https://stackoverflow.com/questions/25948813/read-line-by-line-for-big-files"
  ([file]
   (process-file-by-lines file identity))
  ([file process-fn]
   (process-file-by-lines file process-fn println))
  ([file process-fn output-fn]
   (with-open [rdr (io/reader file)]
     (doseq [line (line-seq rdr)]
       (output-fn
         (process-fn line))))))

(defn -main [input-file]
  (process-file-by-lines input-file record/parse))
#+end_src

  Lets create a sample input file to test with

#+begin_src text :tangle resources/sample-file-1 :results silent :eval no
foo | bar | neutral | chartreuse | 1/1/2020
Luke, Skywalker, male, blue, 1/1/0
SpongeBob Squarepants none? pinaple-yellow 5/1/1999
#+end_src

  We can now run a program that for now just prints each line we parse.

#+BEGIN_SRC bash :exports both
clojure -m simple-app.core resources/sample-file-1
#+END_SRC

#+RESULTS:
| {:first-name foo       | :last-name bar         | :gender neutral | :favorite-color chartreuse     | 2020-01-01T08:00:00.000-00:00 |
| {:first-name Luke      | :last-name Skywalker   | :gender male    | :favorite-color blue           | 2000-01-01T08:00:00.000-00:00 |
| {:first-name SpongeBob | :last-name Squarepants | :gender none?   | :favorite-color pinaple-yellow | 1999-05-01T07:00:00.000-00:00 |

** Data output

  We actually want to output data in 3 different views.

  * Output 1 – sorted by gender (females before males) then by last name ascending.
  * Output 2 – sorted by birth date, ascending.
  * Output 3 – sorted by last name, descending.

  Since we can use the ~sort-by~ function to do the sorting we are going to
  write tests for a comparator functions for each of our options.

  Lets write some starting comparators.

#+begin_src clojure :ns simple-app.record :tangle src/simple_app/record.clj :results silent
(defn by-gender
  "Gender comparator function"
  [a b]
  (compare a b))

(defn by-birth-date
  "Gender comparator function"
  [a b]
  (compare a b))

(defn by-last-name
  "Last Name comparator function"
  [a b]
  (compare a b))
#+end_src

  Lest write this tests.

#+begin_src clojure :ns simple-app.record-test :tangle test/simple_app/record_test.clj :results silent
(deftest sort-tests
  (testing "by-gender"
    (is (= 0 (record/by-gender "female" "female"))
        "same")
    (is (= -1 (record/by-gender "female" "male"))
        "female before male")
    (is (= 1 (record/by-gender "male" "female"))
        "male after female")

    (is (= -1 (record/by-gender "female" "other"))
        "female before other")
    (is (= 1 (record/by-gender "other" "female"))
        "other after female")

    (is (= -1 (record/by-gender "male" "other"))
        "male before other")
    (is (= 1 (record/by-gender "other" "male"))
        "other after male"))
  (testing "birth-date"
    (is (= 0 (record/by-birth-date (java.util.Date. "1/1/2020")
                                   (java.util.Date. "1/1/2020")))
        "same")
    (is (= -1 (record/by-birth-date (java.util.Date. "1/1/2020")
                                    (java.util.Date. "1/2/2020")))
        "ascending")
    (is (= 1 (record/by-birth-date (java.util.Date. "1/2/2020")
                                   (java.util.Date. "1/1/2020")))))
  (testing "last-name"
    (is (= 0 (record/by-last-name "Viramontes" "Viramontes"))
        "same")
    (is (> 0 (record/by-last-name "Viramontes" "Jenkins"))
        "descending")
    (is (< 0 (record/by-last-name "Jenkins" "Viramontes")))))
#+end_src

  Lets see the initial results.

#+begin_src clojure :ns clojure.test :tangle dev/scratch.clj :results output :exports both
(run-tests 'simple-app.record-test)
#+end_src

#+RESULTS:
#+begin_example

Testing simple-app.record-test

FAIL in (sort-tests) (NO_SOURCE_FILE:6)
by-gender
female before male
expected: (= -1 (record/by-gender "female" "male"))
  actual: (not (= -1 -7))

FAIL in (sort-tests) (NO_SOURCE_FILE:8)
by-gender
male after female
expected: (= 1 (record/by-gender "male" "female"))
  actual: (not (= 1 7))

FAIL in (sort-tests) (NO_SOURCE_FILE:11)
by-gender
female before other
expected: (= -1 (record/by-gender "female" "other"))
  actual: (not (= -1 -9))

FAIL in (sort-tests) (NO_SOURCE_FILE:13)
by-gender
other after female
expected: (= 1 (record/by-gender "other" "female"))
  actual: (not (= 1 9))

FAIL in (sort-tests) (NO_SOURCE_FILE:16)
by-gender
male before other
expected: (= -1 (record/by-gender "male" "other"))
  actual: (not (= -1 -2))

FAIL in (sort-tests) (NO_SOURCE_FILE:18)
by-gender
other after male
expected: (= 1 (record/by-gender "other" "male"))
  actual: (not (= 1 2))

FAIL in (sort-tests) (NO_SOURCE_FILE:32)
last-name
descending
expected: (> 0 (record/by-last-name "Viramontes" "Jenkins"))
  actual: (not (> 0 12))

FAIL in (sort-tests) (NO_SOURCE_FILE:34)
last-name
expected: (< 0 (record/by-last-name "Jenkins" "Viramontes"))
  actual: (not (< 0 -12))

Ran 2 tests containing 16 assertions.
8 failures, 0 errors.
#+end_example

  OK lets make the tests pass. Notice the Birth date comparator already works as
  is. We'll need a bit of logic for the gender comparator and a very simple
  parameter swap for the last-name comparator.

#+begin_src clojure :ns simple-app.record :tangle src/simple_app/record.clj :results silent
(defn by-gender
  "Gender comparator function"
  [a b]
  (cond
    (= a b)
    0
    (= a "female")
    -1
    (= b "female")
    1
    (and (= a "male") (not= b "female"))
    -1
    (and (= b "male") (not= a "female"))
    1))

(defn by-birth-date
  "Gender comparator function"
  [a b]
  (compare a b))

(defn by-last-name
  "Last Name comparator function"
  [a b]
  (compare b a))
#+end_src

  Now our tests are passing.

#+begin_src clojure :ns clojure.test :tangle dev/scratch.clj :results output :exports both
(run-tests 'simple-app.record-test)
#+end_src

#+RESULTS:
: 
: Testing simple-app.record-test
: 
: Ran 2 tests containing 16 assertions.
: 0 failures, 0 errors.

  Lets put it all together in our main entrypoint.

#+begin_src clojure :ns simple-app.core :tangle src/simple_app/core.clj :results silent
(require '[clojure.pprint :as pprint])
(require '[clojure.spec.alpha :as s])
(require '[simple-app.spec])

(defn -main [input-file]
  (let [data (atom [])]
    (process-file-by-lines input-file record/parse (partial swap! data conj))
    (prn "Validating data")
    (s/explain :simple-app/records @data)
    (when (s/valid? :simple-app/records @data)
      (prn "Sorted by gender, then last-name")
      (pprint/print-table (->> @data
                               (sort-by :last-name)
                               (sort-by :gender record/by-gender)))
      (prn "Sorted by birth-date, ascending")
      (pprint/print-table (->> @data
                               (sort-by :date-of-birth record/by-birth-date)))
      (prn "Sorted by last-name, descending")
      (pprint/print-table (->> @data
                               (sort-by :last-name record/by-last-name))))))

#+end_src

  We need a more interesting sample input file now
 
#+begin_src text :tangle resources/sample-file-2 :results silent :eval no
boo | far | female | chartreuse | 1/1/2020
foo | bar | female | chartreuse | 1/1/2020
Luke | Skywalker | male | blue | 1/1/2000
SpongeBob | Squarepants | wat? | pinaple-yellow | 5/3/1999
Rey | Palpatine | female | yellow | 1/1/2034
#+end_src

#+BEGIN_SRC bash :results output :exports both
clojure -m simple-app.core resources/sample-file-2
#+END_SRC

#+RESULTS:
#+begin_example
"Validating data"
Success!
"Sorted by gender, then last-name"

| :first-name |  :last-name | :gender | :favorite-color |               :date-of-birth |
|-------------+-------------+---------+-----------------+------------------------------|
|         Rey |   Palpatine |  female |          yellow | Sun Jan 01 00:00:00 PST 2034 |
|         foo |         bar |  female |      chartreuse | Wed Jan 01 00:00:00 PST 2020 |
|         boo |         far |  female |      chartreuse | Wed Jan 01 00:00:00 PST 2020 |
|        Luke |   Skywalker |    male |            blue | Sat Jan 01 00:00:00 PST 2000 |
|   SpongeBob | Squarepants |    wat? |  pinaple-yellow | Mon May 03 00:00:00 PDT 1999 |
"Sorted by birth-date, ascending"

| :first-name |  :last-name | :gender | :favorite-color |               :date-of-birth |
|-------------+-------------+---------+-----------------+------------------------------|
|   SpongeBob | Squarepants |    wat? |  pinaple-yellow | Mon May 03 00:00:00 PDT 1999 |
|        Luke |   Skywalker |    male |            blue | Sat Jan 01 00:00:00 PST 2000 |
|         boo |         far |  female |      chartreuse | Wed Jan 01 00:00:00 PST 2020 |
|         foo |         bar |  female |      chartreuse | Wed Jan 01 00:00:00 PST 2020 |
|         Rey |   Palpatine |  female |          yellow | Sun Jan 01 00:00:00 PST 2034 |
"Sorted by last-name, descending"

| :first-name |  :last-name | :gender | :favorite-color |               :date-of-birth |
|-------------+-------------+---------+-----------------+------------------------------|
|         boo |         far |  female |      chartreuse | Wed Jan 01 00:00:00 PST 2020 |
|         foo |         bar |  female |      chartreuse | Wed Jan 01 00:00:00 PST 2020 |
|   SpongeBob | Squarepants |    wat? |  pinaple-yellow | Mon May 03 00:00:00 PDT 1999 |
|        Luke |   Skywalker |    male |            blue | Sat Jan 01 00:00:00 PST 2000 |
|         Rey |   Palpatine |  female |          yellow | Sun Jan 01 00:00:00 PST 2034 |
#+end_example

  Oh shoot! Something does not look right with the last-name ordering. It turns
  out Clojure sort uses ASCII character ordering to compare strings. Thats
  something I did not know. Anyway lets fix it and write a test for it.

#+begin_src clojure :ns simple-app.record-test :tangle test/simple_app/record_test.clj :results silent
(deftest last-name-sort-case-tests
  (testing "last-name"
    (is (= 0 (record/by-last-name "Viramontes" "viramontes"))
        "same")
    (is (> 0 (record/by-last-name "Viramontes" "jenkins"))
        "descending")
    (is (< 0 (record/by-last-name "jenkins" "Viramontes")))))
#+end_src

  Lets see the initial results.

#+begin_src clojure :ns clojure.test :tangle dev/scratch.clj :results output :exports both
(run-tests 'simple-app.record-test)
#+end_src

#+RESULTS:
#+begin_example

Testing simple-app.record-test

FAIL in (last-name-sort-case-tests) (NO_SOURCE_FILE:4)
last-name
same
expected: (= 0 (record/by-last-name "Viramontes" "viramontes"))
  actual: (not (= 0 32))

FAIL in (last-name-sort-case-tests) (NO_SOURCE_FILE:6)
last-name
descending
expected: (> 0 (record/by-last-name "Viramontes" "jenkins"))
  actual: (not (> 0 20))

FAIL in (last-name-sort-case-tests) (NO_SOURCE_FILE:8)
last-name
expected: (< 0 (record/by-last-name "jenkins" "Viramontes"))
  actual: (not (< 0 -20))

Ran 3 tests containing 19 assertions.
3 failures, 0 errors.
#+end_example

  Lets fix the damn thing.

#+begin_src clojure :ns simple-app.record :tangle src/simple_app/record.clj :results silent
(defn by-last-name
  "Last Name comparator function"
  [a b]
  (compare (str/upper-case b) (str/upper-case a)))
#+end_src

#+begin_src clojure :ns clojure.test :tangle dev/scratch.clj :results output :exports both
(run-tests 'simple-app.record-test)
#+end_src

#+RESULTS:
: 
: Testing simple-app.record-test
: 
: Ran 3 tests containing 19 assertions.
: 0 failures, 0 errors.

  Oh! and we need to display the dates in ~M/D/YYYY~ format.

#+begin_src clojure :ns simple-app.core :tangle src/simple_app/core.clj :results silent
(require '[clojure.walk :as walk])

(defn with-formated-dates
  "Given a data structure formats dates as `MM/dd/yyyy`"
  [data]
  (walk/postwalk (fn [x]
                   (if (= (class x)
                          java.util.Date)
                     (.format (java.text.SimpleDateFormat. "MM/dd/yyyy") x)
                     x))
                 data))

(defn -main [input-file]
  (let [data (atom [])]
    (process-file-by-lines input-file record/parse (partial swap! data conj))
    (prn "Validating data")
    (s/explain :simple-app/records @data)
    (when (s/valid? :simple-app/records @data)
      (prn "Sorted by gender, then last-name")
      (pprint/print-table (->> @data
                               (sort-by :last-name)
                               (sort-by :gender record/by-gender)
                               (with-formated-dates)))
      (prn "Sorted by birth-date, ascending")
      (pprint/print-table (->> @data
                               (sort-by :date-of-birth record/by-birth-date)
                               (with-formated-dates)))
      (prn "Sorted by last-name, descending")
      (pprint/print-table (->> @data
                               (sort-by :last-name record/by-last-name)
                               (with-formated-dates))))))
#+end_src

#+BEGIN_SRC bash :results output :exports both
clojure -m simple-app.core resources/sample-file-2
#+END_SRC

#+RESULTS:
#+begin_example
"Validating data"
Success!
"Sorted by gender, then last-name"

| :first-name |  :last-name | :gender | :favorite-color | :date-of-birth |
|-------------+-------------+---------+-----------------+----------------|
|         Rey |   Palpatine |  female |          yellow |     01/01/2034 |
|         foo |         bar |  female |      chartreuse |     01/01/2020 |
|         boo |         far |  female |      chartreuse |     01/01/2020 |
|        Luke |   Skywalker |    male |            blue |     01/01/2000 |
|   SpongeBob | Squarepants |    wat? |  pinaple-yellow |     05/03/1999 |
"Sorted by birth-date, ascending"

| :first-name |  :last-name | :gender | :favorite-color | :date-of-birth |
|-------------+-------------+---------+-----------------+----------------|
|   SpongeBob | Squarepants |    wat? |  pinaple-yellow |     05/03/1999 |
|        Luke |   Skywalker |    male |            blue |     01/01/2000 |
|         boo |         far |  female |      chartreuse |     01/01/2020 |
|         foo |         bar |  female |      chartreuse |     01/01/2020 |
|         Rey |   Palpatine |  female |          yellow |     01/01/2034 |
"Sorted by last-name, descending"

| :first-name |  :last-name | :gender | :favorite-color | :date-of-birth |
|-------------+-------------+---------+-----------------+----------------|
|   SpongeBob | Squarepants |    wat? |  pinaple-yellow |     05/03/1999 |
|        Luke |   Skywalker |    male |            blue |     01/01/2000 |
|         Rey |   Palpatine |  female |          yellow |     01/01/2034 |
|         boo |         far |  female |      chartreuse |     01/01/2020 |
|         foo |         bar |  female |      chartreuse |     01/01/2020 |
#+end_example

  NOTE: I tried using ~pprint/with-pprint-dispatch~ but it was not possible as
  the ~pprint/print-table~ function first converts data to strings to calculate
  the column widths.

  
** REST service

   Now we are going to write a simple rest service to access the data in the
   system. We are going to use an ~atom~ as mock for our persistent storage.
   
   Since creating a rest service is mostly boilerplate code and our core
   "business logic" is already tested I am going to put the whole service in one
   go.
   
#+begin_src clojure :tangle src/simple_app/record_service.clj :results silent
(ns simple-app.record-service
  (:require [clojure.data.json :as json]
            [clojure.walk :as walk]
            [io.pedestal.http.route :as route]
            [io.pedestal.test :as test]
            [simple-app.record :as record]))

(defn response [status body & {:as headers}]
  {:status status :body body :headers headers})

(def ok (partial response 200))
(def created (partial response 201))
(def bad-request (partial response 400))
;;;
;;; "Database" functions
;;;
(defonce database (atom []))

(defn record-insert
  [dbval new-record]
  (conj dbval new-record))

(def db-interceptor
  {:name :database-interceptor
   :enter
   (fn [context]
     (update context :request assoc :database @database))
   :leave
   (fn [context]
     (if-let [[op & args] (:tx-data context)]
       (do
         (apply swap! database op args)
         (assoc-in context [:request :database] @database))
       context))})

;;;
;;; Domain functions
;;;
(defn parse-record [unparsed-record]
  (when (string? unparsed-record)
    (record/parse unparsed-record)))

(defn sorted-records
  [data sort-by-param]
  (case sort-by-param
    "name"
    (sort-by :last-name record/by-last-name data)
    "gender"
    (sort-by :gender record/by-gender data)
    "birthdate"
    (sort-by :date-of-birth record/by-birth-date data)
    nil))

(defn with-formated-dates
  "Given a data structure formats dates as `MM/dd/yyyy`"
  [data]
  (walk/postwalk (fn [x]
                   (if (= (class x)
                          java.util.Date)
                     (.format (java.text.SimpleDateFormat. "MM/dd/yyyy") x)
                     x))
                 data))

(defn record->json [data]
  (json/write-str (with-formated-dates data)))

(defn transform-to-json
  [response]
  (-> response
      (update :body record->json)
      (assoc-in [:headers "Content-Type"] "application/json")))
;;;
;;; API Interceptors
;;;
(def record-render
  {:name :record-render
   :leave
   (fn [context]
     (if-let [item (:result context)]
       (assoc context :response (ok item))
       context))})

(def record-create
  {:name :record-create
   :enter
   (fn [context]
     (let [body-stream (get-in context [:request :body])
           unparsed-record (slurp body-stream)
           new-record (parse-record unparsed-record)]
       (if new-record
         (-> context
             (assoc :tx-data [record-insert new-record])
             (assoc :response (created new-record)))
         (assoc context :response (bad-request "invalid record")))))})

(def list-view
  {:name :list-view
   :enter
   (fn [context]
     (if-let [sort-by-param (get-in context [:request :path-params :sort-by])]
       (if-let [records (sorted-records (get-in context [:request :database]) sort-by-param)]
         (assoc context :result records)
         context)
       context))})

(def coerce-body
  {:name ::coerce-body
   :leave
   (fn [context]
     (update-in context [:response] transform-to-json))})

(def routes
  (route/expand-routes
   #{["/records" :post [coerce-body db-interceptor record-create]]
     ["/records/:sort-by" :get [coerce-body record-render db-interceptor list-view]]}))
#+end_src
  
  While there is definitely value to having unit tests for some of the above
  functions, in this case, since it is a simple application we are going to do
  some interactive validation for now. In fact, with clojure its sometimes
  easier to explore code interactively, specially if one is learning. I usually
  factor our tests for posterity once I ironed out the kinks and feel more
  confortable with my knowkedge of using a new library.

#+begin_src clojure :ns simple-app.record-service :tangle dev/scratch.clj :results output :exports both
(require '[io.pedestal.http :as http])
(defonce server (atom nil))

(defn start-dev []
  (reset! server
          (http/start (http/create-server
                       {::http/routes service/routes
                        ::http/type   :jetty
                        ::http/port   8890
                        ::http/join? false}))))

(defn stop-dev []
  (http/stop @server))

(defn restart []
  (stop-dev)
  (start-dev))

(defn test-request [& params]
  (apply (partial test/response-for (::http/service-fn @server)) params))

(start-dev)
#+end_src

#+RESULTS:
: [nREPL-session-891a1df0-453c-440d-9973-2c97f12a17f8] INFO org.eclipse.jetty.util.log - Logging initialized @68726ms to org.eclipse.jetty.util.log.Slf4jLog
: [nREPL-session-891a1df0-453c-440d-9973-2c97f12a17f8] INFO org.eclipse.jetty.server.Server - jetty-9.4.18.v20190429; built: 2019-04-29T20:42:08.989Z; git: e1bc35120a6617ee3df052294e433f3a25ce7097; jvm 14.0.2+12
: [nREPL-session-891a1df0-453c-440d-9973-2c97f12a17f8] INFO org.eclipse.jetty.server.handler.ContextHandler - Started o.e.j.s.ServletContextHandler@3e2f78b3{/,null,AVAILABLE}
: [nREPL-session-891a1df0-453c-440d-9973-2c97f12a17f8] INFO org.eclipse.jetty.server.AbstractConnector - Started ServerConnector@60d6ef6b{HTTP/1.1,[http/1.1, h2c]}{localhost:8880}
: [nREPL-session-891a1df0-453c-440d-9973-2c97f12a17f8] INFO org.eclipse.jetty.server.Server - Started @68856ms

  Lets write one valid entry to our database. Notice the response returns the
  JSON version of the parsed data.

#+begin_src clojure :ns simple-app.record-service :tangle dev/scratch.clj :results output :wrap src json :exports both
(-> (test-request :post "/records"
                  :headers {"Content-Type" "text/plain"}
                  :body "boo | far | female | chartreuse | 1/1/2020")
    :body
    json/read-str
    json/pprint)
#+end_src

#+RESULTS:
#+begin_src json
{"first-name":"boo",
 "last-name":"far",
 "gender":"female",
 "favorite-color":"chartreuse",
 "date-of-birth":"01\/01\/2020"}
#+end_src

  Now lets list that entry sorted by name. Noticed we now get that one entry
  inside of a list.

#+begin_src clojure :ns simple-app.record-service :tangle dev/scratch.clj :results output :wrap src json :exports both
(-> (test-request :get "/records/name")
    :body
    json/read-str
    json/pprint)
#+end_src

#+RESULTS:
#+begin_src json
[{"first-name":"boo",
  "last-name":"far",
  "gender":"female",
  "favorite-color":"chartreuse",
  "date-of-birth":"01\/01\/2020"}]
#+end_src

  Lets load our database as we had done before. We'll clear the data fist.

#+begin_src clojure :ns simple-app.record-service :tangle dev/scratch.clj :results silent
(require '[simple-app.core :as core])
(require '[simple-app.record :as record])
(reset! database [])
(core/process-file-by-lines "resources/sample-file-2" record/parse (partial swap! database conj))
#+end_src

  Now lets see them sorted by gender. We can see the ordering is correct. 

#+begin_src clojure :ns simple-app.record-service :tangle dev/scratch.clj :results output :wrap src json :exports both
(-> (test-request :get "/records/gender")
    :body
    json/read-str
    json/pprint)
#+end_src

#+RESULTS:
#+begin_src json
[{"first-name":"boo",
  "last-name":"far",
  "gender":"female",
  "favorite-color":"chartreuse",
  "date-of-birth":"01\/01\/2020"},
 {"first-name":"foo",
  "last-name":"bar",
  "gender":"female",
  "favorite-color":"chartreuse",
  "date-of-birth":"01\/01\/2020"},
 {"first-name":"Rey",
  "last-name":"Palpatine",
  "gender":"female",
  "favorite-color":"yellow",
  "date-of-birth":"01\/01\/2034"},
 {"first-name":"Luke",
  "last-name":"Skywalker",
  "gender":"male",
  "favorite-color":"blue",
  "date-of-birth":"01\/01\/2000"},
 {"first-name":"SpongeBob",
  "last-name":"Squarepants",
  "gender":"wat?",
  "favorite-color":"pinaple-yellow",
  "date-of-birth":"05\/03\/1999"}]
#+end_src

  For good measure lets see the ordering by birthdate.

#+begin_src clojure :ns simple-app.record-service :tangle dev/scratch.clj :results output :wrap src json :exports both
(-> (test-request :get "/records/birthdate")
    :body
    json/read-str
    json/pprint)
#+end_src

#+RESULTS:
#+begin_src json
[{"first-name":"SpongeBob",
  "last-name":"Squarepants",
  "gender":"wat?",
  "favorite-color":"pinaple-yellow",
  "date-of-birth":"05\/03\/1999"},
 {"first-name":"Luke",
  "last-name":"Skywalker",
  "gender":"male",
  "favorite-color":"blue",
  "date-of-birth":"01\/01\/2000"},
 {"first-name":"boo",
  "last-name":"far",
  "gender":"female",
  "favorite-color":"chartreuse",
  "date-of-birth":"01\/01\/2020"},
 {"first-name":"foo",
  "last-name":"bar",
  "gender":"female",
  "favorite-color":"chartreuse",
  "date-of-birth":"01\/01\/2020"},
 {"first-name":"Rey",
  "last-name":"Palpatine",
  "gender":"female",
  "favorite-color":"yellow",
  "date-of-birth":"01\/01\/2034"}]
#+end_src

  Lets make sure our list routes are correct.

#+begin_src clojure :ns simple-app.record-service :tangle dev/scratch.clj :results output :exports both
(println (test-request :get "/records"))
(println (test-request :get "/records/"))
(println (test-request :get "/records/other"))
#+end_src

#+RESULTS:
: {:status 404, :body Not Found, :headers {Content-Type text/plain}}
: {:status 404, :body Not Found, :headers {Content-Type text/plain}}
: {:status 404, :body Not Found, :headers {Content-Type text/plain}}

  What about posting bad data.

#+begin_src clojure :ns simple-app.record-service :tangle dev/scratch.clj :results output :exports both
(test-request :post "/records"
              :headers {"Content-Type" "text/plain"}
              :body "")
#+end_src

#+RESULTS:
#+begin_example
[nREPL-session-891a1df0-453c-440d-9973-2c97f12a17f8] INFO io.pedestal.http - {:msg "POST /records", :line 80}
[nREPL-session-891a1df0-453c-440d-9973-2c97f12a17f8] ERROR io.pedestal.http.impl.servlet-interceptor - {:msg "error-ring-response triggered", :context {:io.pedestal.interceptor.chain/stack (#Interceptor{:name :io.pedestal.http.impl.servlet-interceptor/stylobate} #Interceptor{:name :io.pedestal.http.impl.servlet-interceptor/terminator-injector}), :request {:protocol "HTTP/1.1", :async-supported? true, :remote-addr "127.0.0.1", :servlet-response #object[io.pedestal.test$test_servlet_response$reify__22288 0x41bb9cf8 "io.pedestal.test$test_servlet_response$reify__22288@41bb9cf8"], :servlet #object[io.pedestal.http.servlet.FnServlet 0xb0a1e67 "io.pedestal.http.servlet.FnServlet@b0a1e67"], :headers {"content-type" "text/plain", "content-length" "0"}, :server-port -1, :servlet-request #object[io.pedestal.test$test_servlet_request$reify__22276 0x3c41dee3 "io.pedestal.test$test_servlet_request$reify__22276@3c41dee3"], :content-length 0, :content-type "text/plain", :path-info "/records", :character-encoding "UTF-8", :database [{:first-name "boo", :last-name "far", :gender "female", :favorite-color "chartreuse", :date-of-birth #inst "2020-01-01T08:00:00.000-00:00"} {:first-name "foo", :last-name "bar", :gender "female", :favorite-color "chartreuse", :date-of-birth #inst "2020-01-01T08:00:00.000-00:00"} {:first-name "Luke", :last-name "Skywalker", :gender "male", :favorite-color "blue", :date-of-birth #inst "2000-01-01T08:00:00.000-00:00"} {:first-name "SpongeBob", :last-name "Squarepants", :gender "wat?", :favorite-color "pinaple-yellow", :date-of-birth #inst "1999-05-03T07:00:00.000-00:00"} {:first-name "Rey", :last-name "Palpatine", :gender "female", :favorite-color "yellow", :date-of-birth #inst "2034-01-01T08:00:00.000-00:00"}], :url-for #delay[{:status :pending, :val nil} 0x41cbc430], :uri "/records", :server-name nil, :query-string nil, :path-params {}, :body #object[io.pedestal.test.proxy$javax.servlet.ServletInputStream$ff19274a 0x5c0accad "io.pedestal.test.proxy$javax.servlet.ServletInputStream$ff19274a@5c0accad"], :scheme nil, :request-method :post, :context-path ""}, :bindings {#'io.pedestal.http.route/*url-for* #delay[{:status :pending, :val nil} 0x41cbc430]}, :enter-async [#function[io.pedestal.http.impl.servlet-interceptor/start-servlet-async]], :io.pedestal.interceptor.chain/terminators (#function[io.pedestal.http.impl.servlet-interceptor/terminator-inject/fn--22015]), :servlet-response #object[io.pedestal.test$test_servlet_response$reify__22288 0x41bb9cf8 "io.pedestal.test$test_servlet_response$reify__22288@41bb9cf8"], :route {:path "/records", :method :post, :path-re #"/\Qrecords\E", :path-parts ["records"], :interceptors [#Interceptor{:name :simple-app.record-service/coerce-body} #Interceptor{:name :database-interceptor} #Interceptor{:name :record-create}], :route-name :record-create, :path-params {}, :io.pedestal.http.route.prefix-tree/satisfies-constraints? #function[clojure.core/constantly/fn--5672]}, :servlet #object[io.pedestal.http.servlet.FnServlet 0xb0a1e67 "io.pedestal.http.servlet.FnServlet@b0a1e67"], :servlet-request #object[io.pedestal.test$test_servlet_request$reify__22276 0x3c41dee3 "io.pedestal.test$test_servlet_request$reify__22276@3c41dee3"], :url-for #delay[{:status :pending, :val nil} 0x41cbc430], :io.pedestal.interceptor.chain/execution-id 80, :servlet-config nil, :async? #function[io.pedestal.http.impl.servlet-interceptor/servlet-async?]}, :line 253}
clojure.lang.ExceptionInfo: java.lang.IllegalArgumentException in Interceptor :record-create -  {:execution-id 80, :stage :enter, :interceptor :record-create, :exception-type :java.lang.IllegalArgumentException, :exception #error {
 :cause nil
 :via
 [{:type java.lang.IllegalArgumentException
   :message nil
   :at [java.util.Date parse "Date.java" 617]}]
 :trace {{ommited}}
 [nREPL-session-891a1df0-453c-440d-9973-2c97f12a17f8] INFO io.pedestal.http.impl.servlet-interceptor - {:msg "sending error", :message "Internal server error: exception", :line 215}
#+end_example

  AHA! we found an issue! Seems that our date parsing function blows up when it
  gets nil data. We'll need to guard against that. Lets add to our parse tests.

 #+begin_src clojure :ns simple-app.record-test :tangle test/simple_app/record_test.clj :results silent
(deftest handle-bad-data-test
  (let [expected nil
        bad-date "foo | bar | neutral | chartreuse | foo"
        empty-data ""
        weird-data "klj;a f``jsaldkf asld kflask dfjl;kasdl;kfjaslkdfjl;kasd  aslk jflk;a sdl;kfjs"]

    (testing "Bad date"
      (is (= (record/parse bad-date) expected)))
    (testing "Empty data"
      (is (= (record/parse empty-data) expected)))
    (testing "Wat?"
      (is (= (record/parse weird-data) expected)))))
#+end_src
 
#+begin_src clojure :ns clojure.test :tangle dev/scratch.clj :results value :exports both
(run-tests 'simple-app.record-test)
#+end_src

#+RESULTS:
: nil{:test 2, :pass 3, :fail 0, :error 3, :type :summary}

  Lets add guarding against bad data by taking advantage of out specs :D

#+begin_src clojure :ns simple-app.record :tangle src/simple_app/record.clj :results silent
(require '[clojure.string :as str])
(require '[clojure.spec.alpha :as s])
(require '[simple-app.spec])

(defn parse
  "Parses input line into a record entry map.
  Handles 3 different input formats.
    - Comma separated
    - Pipe separated
    - Space separated"
  [line]
  (let [validate (fn [entry]
                   (when (s/valid? :simple-app/record entry) entry))]
    (-> (zipmap [:first-name :last-name :gender :favorite-color :date-of-birth]
                (str/split line #",\s+|\s+\|\s+|\s+"))
        (update :date-of-birth #(try (java.util.Date. %) (catch Exception _ nil)))
        (validate))))
#+end_src

  Tests are passing now :D

#+begin_src clojure :ns clojure.test :tangle dev/scratch.clj :results output :exports both
(run-tests 'simple-app.record-test)
#+end_src

#+RESULTS:
: 
: Testing simple-app.record-test
: 
: Ran 2 tests containing 6 assertions.
: 0 failures, 0 errors.

  Now we can see that we get a 400 from the API as expected.

#+begin_src clojure :ns simple-app.record-service :tangle dev/scratch.clj :results output :wrap src json  :exports both
(json/pprint (test-request :post "/records"
                           :headers {"Content-Type" "text/plain"}
                           :body ""))
#+end_src

#+RESULTS:
#+begin_src json
{"status":400,
 "body":"\"invalid record\"",
 "headers":
 {"Strict-Transport-Security":"max-age=31536000; includeSubdomains",
  "X-Frame-Options":"DENY",
  "X-Content-Type-Options":"nosniff",
  "X-XSS-Protection":"1; mode=block",
  "X-Download-Options":"noopen",
  "X-Permitted-Cross-Domain-Policies":"none",
  "Content-Security-Policy":
  "object-src 'none'; script-src 'unsafe-inline' 'unsafe-eval' 'strict-dynamic' https: http:;",
  "Content-Type":"application\/json"}}
#+end_src

** Putting a bow on it.

  In a production system I would use integrant to describe the system and handle
  its state. In this case it would be total overkill as there is only one real
  component to the system. So we'll do the "poor mans" system for this example.

#+begin_src clojure :tangle src/simple_app/system.clj :results silent
(ns simple-app.system
  (:require [io.pedestal.http :as http]
            [simple-app.record-service :as service]
            [simple-app.record :as record]
            [simple-app.core :as core]))

(def system nil)

(def service-map
  {::http/routes service/routes
   ::http/type   :jetty
   ::http/port   8080
   ::http/join?  false})

(defn stop
  "Stops the app and clears the database"
  []
  (when system
    (http/stop (:app system)))
  (reset! service/database [])
  (alter-var-root #'system (constantly nil)))

(defn start
  "Resets the app database and starts the app with default database"
  []
  (core/process-file-by-lines "resources/sample-file-2" record/parse (partial swap! service/database conj))
  (alter-var-root #'system
                  merge
                  {:app (http/start (http/create-server service-map))}))

(defn -main []
  (start))
#+end_src

  We can now start the system interactively.

#+begin_src clojure :ns simple-app.system :tangle dev/scratch.clj :results output :wrap :exports both
(stop)
(start)
#+end_src

#+RESULTS:
#+begin_results
[nREPL-session-efdbcfae-92d8-4944-b5b4-81ffda35cdb8] INFO org.eclipse.jetty.server.AbstractConnector - Stopped ServerConnector@4c9cd3de{HTTP/1.1,[http/1.1, h2c]}{localhost:8080}
[nREPL-session-efdbcfae-92d8-4944-b5b4-81ffda35cdb8] INFO org.eclipse.jetty.server.handler.ContextHandler - Stopped o.e.j.s.ServletContextHandler@5219c85b{/,null,UNAVAILABLE}
[nREPL-session-efdbcfae-92d8-4944-b5b4-81ffda35cdb8] INFO org.eclipse.jetty.server.Server - jetty-9.4.18.v20190429; built: 2019-04-29T20:42:08.989Z; git: e1bc35120a6617ee3df052294e433f3a25ce7097; jvm 14.0.2+12
[nREPL-session-efdbcfae-92d8-4944-b5b4-81ffda35cdb8] INFO org.eclipse.jetty.server.handler.ContextHandler - Started o.e.j.s.ServletContextHandler@6a6897af{/,null,AVAILABLE}
[nREPL-session-efdbcfae-92d8-4944-b5b4-81ffda35cdb8] INFO org.eclipse.jetty.server.AbstractConnector - Started ServerConnector@32b843ab{HTTP/1.1,[http/1.1, h2c]}{localhost:8080}
[nREPL-session-efdbcfae-92d8-4944-b5b4-81ffda35cdb8] INFO org.eclipse.jetty.server.Server - Started @24943ms
#+end_results

  Or with thie command line.

#+BEGIN_SRC bash :exports both
clojure -m simple-app.system
#+END_SRC

  Lets curl it.

#+BEGIN_SRC bash :exports both :results output :wrap src json
curl -X GET http://localhost:8080/records/gender | jq .
#+END_SRC

#+RESULTS:
#+begin_src json
[
  {
    "first-name": "boo",
    "last-name": "far",
    "gender": "female",
    "favorite-color": "chartreuse",
    "date-of-birth": "01/01/2020"
  },
  {
    "first-name": "foo",
    "last-name": "bar",
    "gender": "female",
    "favorite-color": "chartreuse",
    "date-of-birth": "01/01/2020"
  },
  {
    "first-name": "Rey",
    "last-name": "Palpatine",
    "gender": "female",
    "favorite-color": "yellow",
    "date-of-birth": "01/01/2034"
  },
  {
    "first-name": "Luke",
    "last-name": "Skywalker",
    "gender": "male",
    "favorite-color": "blue",
    "date-of-birth": "01/01/2000"
  },
  {
    "first-name": "SpongeBob",
    "last-name": "Squarepants",
    "gender": "wat?",
    "favorite-color": "pinaple-yellow",
    "date-of-birth": "05/03/1999"
  }
]
#+end_src

  Profit!

** Final comments on Pedestal.

  It was refreshing to try out Pedestal. I was surprised by the amount of things
  Pedestal forces you to define to do a simple rest interface. It is nice that
  it provides facilities to do interactive development and its less "magical"
  than Ring. I do see the potential that it has for larger APIs as its design
  forces you to keep concerns separated and more unit-like. Even a super simple
  application with two endpoints ended up being a lot of boilerplate but that
  gives you a ton of flexibility to grow the API in a sane way.
